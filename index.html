<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Jascy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jascy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jascy">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="chen peng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jascy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jascy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-My-New-Post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/29/My-New-Post/" class="article-date">
  <time datetime="2020-05-29T09:53:13.000Z" itemprop="datePublished">2020-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/29/My-New-Post/">My New Post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OpenCV学习指南"><a href="#OpenCV学习指南" class="headerlink" title="OpenCV学习指南"></a>OpenCV学习指南</h2><p>这个OpenCV教程是供初学者入门的基础知识。在本指南中，您将学习使用Python使用OpenCV库进行的基本图像处理操作。虽然本教程针对刚入门图像处理和OpenCV库的初学者，但即使您有经验，我还是鼓励您阅读它。快速复习OpenCV基础知识也将帮助您完成自己的项目。</p>
<h3 id="在系统上安装OpenCV和Imutils"><a href="#在系统上安装OpenCV和Imutils" class="headerlink" title="在系统上安装OpenCV和Imutils"></a>在系统上安装OpenCV和Imutils</h3><p>第一步是在系统上安装OpenCV，并设置新的OpenCV开发环境，然后通过pip安装imutils软件包。如果没有安装opencV，ubuntu下可通过下列命令安装：`</p>
<p> 使用pip将OpenCV安装到您的Ubuntu系统中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install opencv-contrib-python</span><br></pre></td></tr></table></figure>
<p>使用pip将OpenCV安装到虚拟环境中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv virtualenvwrapper</span><br></pre></td></tr></table></figure>
<p>在我们继续之前，您首先需要使用nano、vim或emacs打开~/bashrc文件，并将下面的命令行追加到末尾:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virtualenv and virtualenvwrapper</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br><span class="line">$ mkvirtualenv cv -p python3</span><br><span class="line">$ pip install opencv-contrib-python</span><br></pre></td></tr></table></figure>
<h4 id="在系统上安装Imutils"><a href="#在系统上安装Imutils" class="headerlink" title="在系统上安装Imutils"></a>在系统上安装Imutils</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install imutils</span><br></pre></td></tr></table></figure>
<h3 id="加载并显示图像"><a href="#加载并显示图像" class="headerlink" title="加载并显示图像"></a>加载并显示图像</h3><p><img src="https://img-blog.csdnimg.cn/20191111204746919.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt=""><br>图1：使用Python学习OpenCV基础知识是从加载和显示图像开始的，这是一个仅需要几行代码的简单过程。<br>首先，  在您喜欢的文本编辑器或IDE中打开 opencv_tutorial_01 .py.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line">import imutils</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># load the input image and show its dimensions, keeping in mind that</span></span><br><span class="line"><span class="comment"># images are represented as a multi-dimensional NumPy array with</span></span><br><span class="line"><span class="comment"># shape no. rows (height) x no. columns (width) x no. channels (depth)</span></span><br><span class="line">image = cv2.imread(<span class="string">"jp.png"</span>)</span><br><span class="line">(h, w, d) = image.shape</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"width=&#123;&#125;, height=&#123;&#125;, depth=&#123;&#125;"</span>.format(w, h, d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># display the image to our screen -- we will need to click the window</span></span><br><span class="line"><span class="comment"># open by OpenCV and press a key on our keyboard to continue execution</span></span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width=600, height=322, depth=3</span><br></pre></td></tr></table></figure>
<h2 id="访问单个像素"><a href="#访问单个像素" class="headerlink" title="访问单个像素"></a>访问单个像素</h2><p><img src="https://img-blog.csdnimg.cn/20191111210003454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Figure 2: Top: grayscale gradient where brighter pixels are closer to 255 and darker pixels are closer to 0. Bottom: RGB venn diagram where brighter pixels are closer to the center.</p>
<h3 id="什么是像素？"><a href="#什么是像素？" class="headerlink" title="什么是像素？"></a>什么是像素？</h3><p>所有图像都由像素组成，这些像素是图像的原始构建块。图像由网格中的像素组成。640 x 480图像具有640列（宽度）和480行（高度）。具有这些尺寸的图像中有 640 * 480 = 307200 像素。<br>灰度图像中的每个像素都有一个代表灰度的值。在OpenCV中，有256种灰度（从0到255）。因此，灰度图像将具有与每个像素关联的灰度值。<br>彩色图像中的像素具有其他信息。在学习图像处理时，您很快就会熟悉几种色彩空间。为简单起见，我们仅考虑RGB颜色空间。<br>在OpenCV中，RGB（红色，绿色，蓝色）颜色空间中的彩色图像具有与每个像素（B ，G ，R ） 相关联的3元组  。<br>请注意，顺序是BGR而不是RGB。这是因为多年前首次开发OpenCV时，标准是BGR订购。多年来，标准现已成为RGB，但OpenCV仍保持这种“传统” BGR顺序以确保不存在现有代码中断。<br>在BGR 3元组的每个值的范围为 [ 0 ，255 ]  。OpenCV中RGB图像中的每个像素有多少种颜色可能性？这很容易： 256 * 256 * 256 = 16777216  。<br>既然我们已经确切知道什么是像素，那么让我们看一下如何检索图像中单个像素的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># access the RGB pixel located at x=50, y=100, keepind in mind that</span></span><br><span class="line"><span class="comment"># OpenCV stores images in BGR order rather than RGB</span></span><br><span class="line">(B, G, R) = image[100, 50]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"R=&#123;&#125;, G=&#123;&#125;, B=&#123;&#125;"</span>.format(R, G, B))</span><br></pre></td></tr></table></figure>
<p>如前所示，我们的图片尺寸为： 宽度= 600 ，高度= 322 ，深度= 3  。我们可以通过指定坐标访问数组中的单个像素值，只要它们在最大宽度和高度之内即可。<br>image[ 100 ，50 ]  ，从位于像素产生BGR值的3元组 X = 50   和 ÿ = 100  （再次，注意，该高度是数行和宽度是数的列 ）。如上所述，OpenCV以BGR顺序存储图像（例如，不同于Matplotlib）。看看提取第19行上像素的颜色通道值有多么简单  。<br>最终的像素值显示在此处的终端上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R=41, G=49, B=37</span><br></pre></td></tr></table></figure>
<h2 id="数组切片和裁剪"><a href="#数组切片和裁剪" class="headerlink" title="数组切片和裁剪"></a>数组切片和裁剪</h2><p>提取“感兴趣区域”（ROI）是图像处理的一项重要技能。<br>举例来说，您正在识别电影中的人脸。首先，您将运行人脸检测算法以查找正在使用的所有帧中人脸的坐标。然后，您需要提取面部ROI，然后保存或处理它们。将所有包含Ian Malcolm博士的镜框放在侏罗纪公园将是一个不错的人脸识别小型项目。<br>现在，让我们手动提取ROI。这可以通过数组切片来实现。<br><img src="https://img-blog.csdnimg.cn/20191111210928514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图3：使用OpenCV进行数组切片可让我们轻松提取感兴趣区域（ROI）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># extract a 100x100 pixel square ROI (Region of Interest) from the</span></span><br><span class="line"><span class="comment"># input image starting at x=320,y=60 at ending at x=420,y=160</span></span><br><span class="line">roi = image[60:160, 320:420]</span><br><span class="line">cv2.imshow(<span class="string">"ROI"</span>, roi)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<h2 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h2><p>调整图像大小很重要，原因有很多。首先，您可能需要调整大图像的大小以适合屏幕。在较小的图像上，图像处理也更快，因为要处理的像素更少。在深度学习的情况下，我们经常忽略宽高比来调整图像的大小，以使体积适合网络，这要求图像是正方形且具有一定尺寸。<br>让我们将原始图像调整为200 x 200像素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># resize the image to 200x200px, ignoring aspect ratio</span></span><br><span class="line">resized = cv2.resize(image, (200, 200))</span><br><span class="line">cv2.imshow(<span class="string">"Fixed Resizing"</span>, resized)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191111211334659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图5：在使用OpenCV保持宽高比的同时调整图像大小的过程分为三个步骤：（1）提取图像尺寸，（2）计算宽高比，（3 cv2.resize）沿一个尺寸调整图像（）的大小，再乘以另一个尺寸由长宽比决定。<br>但是，我们是否可以使调整尺寸时保持宽高比的过程变得更加容易？<br>是! 每次我们要调整图像大小时，都要计算纵横比有点繁琐,我们可以使用imutils包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># manually computing the aspect ratio can be a pain so let's use the</span></span><br><span class="line"><span class="comment"># imutils library instead</span></span><br><span class="line">resized = imutils.resize(image, width=300)</span><br><span class="line">cv2.imshow(<span class="string">"Imutils Resize"</span>, resized)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>在一行代码中，我们保留了宽高比并调整了图像的大小。很简单，您只需要提供目标 宽度   或目标 高度   作为关键字参数即可。</p>
<h2 id="旋转影像"><a href="#旋转影像" class="headerlink" title="旋转影像"></a>旋转影像</h2><p>让我们旋转下一个示例的侏罗纪公园图像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># let's rotate an image 45 degrees clockwise using OpenCV by first</span></span><br><span class="line"><span class="comment"># computing the image center, then constructing the rotation matrix,</span></span><br><span class="line"><span class="comment"># and then finally applying the affine warp</span></span><br><span class="line">center = (w // 2, h // 2)</span><br><span class="line">M = cv2.getRotationMatrix2D(center, -45, 1.0)</span><br><span class="line">rotated = cv2.warpAffine(image, M, (w, h))</span><br><span class="line">cv2.imshow(<span class="string">"OpenCV Rotation"</span>, rotated)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>注： 我们使用 / /   于整数运算（即没有浮点值）执行。<br><img src="https://img-blog.csdnimg.cn/20191111212019551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图7：使用OpenCV围绕中心点旋转图像需要三个步骤：（1）使用图像的宽度和高度计算中心点，（2）使用cv2.getRotationMatrix2D来计算旋转矩阵，以及（3）使用cv2.warpAffine旋转矩阵来扭曲图像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rotation can also be easily accomplished via imutils with less code</span></span><br><span class="line">rotated = imutils.rotate(image, -45)</span><br><span class="line">cv2.imshow(<span class="string">"Imutils Rotation"</span>, rotated)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191111212237586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图8：使用imutils.rotate，我们可以通过一行代码方便地使用OpenCV和Python旋转图像。</p>
<h2 id="究竟为什么图像会被剪掉"><a href="#究竟为什么图像会被剪掉" class="headerlink" title="究竟为什么图像会被剪掉?"></a>究竟为什么图像会被剪掉?</h2><p>问题是，OpenCV并不关心我们的图像在旋转之后是否被剪切并从视图中消失。这很麻烦，所以imutils版本，它将保持整个图像在视图中。称之为rotate_bound：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenCV doesn't "care" if our rotated image is clipped after rotation</span></span><br><span class="line"><span class="comment"># so we can instead use another imutils convenience function to help</span></span><br><span class="line"><span class="comment"># us out</span></span><br><span class="line">rotated = imutils.rotate_bound(image, 45)</span><br><span class="line">cv2.imshow(<span class="string">"Imutils Bound Rotation"</span>, rotated)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191111212521916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图9：imutils的rotate_bound功能将防止OpenCV在旋转过程中剪切图像。</p>
<p>完美！整个图像都在框架中，并且已正确地顺时针旋转45度。</p>
<h2 id="平滑图像"><a href="#平滑图像" class="headerlink" title="平滑图像"></a>平滑图像</h2><p>在许多图像处理管道中，我们必须对图像进行模糊处理以减少高频噪声，这使我们的算法更容易检测和理解图像的实际内容，而不仅仅是  使“迷惑”我们算法的噪声。在OpenCV中，模糊图像非常容易，并且有多种方法可以完成图像。<br><img src="https://img-blog.csdnimg.cn/20191111212707432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图10：使用OpenCV使用11 x 11内核对该图像进行了高斯模糊处理。模糊是许多图像处理管线减少高频噪声的重要步骤。<br>我经常使用 GaussianBlur 函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apply a Gaussian blur with a 11x11 kernel to the image to smooth it,</span></span><br><span class="line"><span class="comment"># useful when reducing high frequency noise</span></span><br><span class="line">blurred = cv2.GaussianBlur(image, (11, 11), 0)</span><br><span class="line">cv2.imshow(<span class="string">"Blurred"</span>, blurred)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<h2 id="在图像上绘图"><a href="#在图像上绘图" class="headerlink" title="在图像上绘图"></a>在图像上绘图</h2><p>在本节中，我们将在输入图像上绘制矩形，圆形和直线。我们还将在图像上覆盖文本。<br>在继续使用OpenCV在图像上进行绘制之前，请注意，在图像上进行绘制操作是就地执行的。因此，在每个代码块的开头，我们制作原始图像的副本，并将副本存储为 输出  。然后，我们继续 在原位输出图像上进行绘制， 以免破坏原始图像。<br>让我们在伊恩·马尔科姆（Ian Malcolm）的脸上绘制一个矩形：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw a 2px thick red rectangle surrounding the face</span></span><br><span class="line">output = image.copy()</span><br><span class="line">cv2.rectangle(output, (320, 60), (420, 160), (0, 0, 255), 2)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2019111121315019.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在让我们在Ellie Sattler博士的脸前放置一个蓝色实心圆圈：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw a blue 20px (filled in) circle on the image centered at</span></span><br><span class="line"><span class="comment"># x=300,y=150</span></span><br><span class="line">output = image.copy()</span><br><span class="line">cv2.circle(output, (300, 150), 20, (255, 0, 0), -1)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>要绘制圆，您需提供以下参数cv2.circle :</p>
<ul>
<li>img : 输出图像。</li>
<li>center : 我们圆的中心坐标。（300 ，150 ）</li>
<li>radius : 圆半径，以像素为单位。 20  像素的值 。</li>
<li>color : 圆形颜色。此时我与蓝色去如由255在BGR元组的G- + R组分B和0表示，(255, 0, 0), -1)。</li>
<li>thickness : 线的粗细。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191111213633210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图12： OpenCV的cv2.circle方法允许您在图像上的任何地方绘制圆。为该示例绘制一个实心圆，由-1线宽参数表示（正值将使线宽变化为圆形轮廓）。<br>接下来，我们将画一条红线。这条线穿过艾莉的头，经过她的眼睛，一直到伊恩的手。<br>如果仔细查看方法参数并将它们与矩形的参数进行比较，您会发现它们是相同的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw a 5px thick red line from x=60,y=20 to x=400,y=200</span></span><br><span class="line">output = image.copy()</span><br><span class="line">cv2.line(output, (60, 20), (400, 200), (0, 0, 255), 5)</span><br><span class="line">cv2.imshow(<span class="string">"Line"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>就像在矩形中一样，我们提供两个点，一个颜色和一个线宽。OpenCV的后端完成其余的工作。<br><img src="https://img-blog.csdnimg.cn/20191111213813547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图13：类似于绘制矩形和圆形，在OpenCV中cv2.line仅使用起点，终点，颜色和厚度即可绘制一条线。<br>通常，您会发现要在图像上覆盖文本以用于显示。如果您正在进行人脸识别，则可能需要在该人的脸上方绘制该人的名字。或者，如果您在计算机视觉事业中取得进步，则可以构建图像分类器或对象检测器。在这些情况下，您会发现要绘制包含类名和概率的文本。<br>让我们看看OpenCV的putText函数如何工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw green text on the image</span></span><br><span class="line">output = image.copy()</span><br><span class="line">cv2.putText(output, <span class="string">"OpenCV + Jurassic Park!!!"</span>, (10, 25), </span><br><span class="line">	cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)</span><br><span class="line">cv2.imshow(<span class="string">"Text"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>OpenCV 的 putText函数负责在图像上绘制文本。让我们看一下所需的参数：</p>
<ul>
<li>img  ：输出图像。</li>
<li>text  ：我们要在图像上写/画的文本字符串。</li>
<li>pt  ：文本的起点。</li>
<li>字体  ：我经常使用 cv2.FONT_HERSHEY_SIMPLEX  。可用字体在此处列出。</li>
<li>scale  ：字体大小乘数。</li>
<li>color  ：文字颜色。</li>
<li>thickness  ：笔划的粗细（以像素为单位）。 </li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191111214132112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图14：通常，您会发现想要在图像上显示文本以进行可视化。使用cv2.putText上面显示的代码，您可以练习在图像上以不同的颜色，字体，大小和/或位置覆盖文本。</p>
<h2 id="计数对象"><a href="#计数对象" class="headerlink" title="计数对象"></a>计数对象</h2><p>在接下来的几节中，我们将学习如何使用创建简单的Python + OpenCV脚本来计算下图中的俄罗斯方块块数：<br><img src="https://img-blog.csdnimg.cn/20191114123830858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line">import argparse</span><br><span class="line">import imutils</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the argument parser and parse the arguments</span></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>, <span class="string">"--image"</span>, required=True,</span><br><span class="line">	<span class="built_in">help</span>=<span class="string">"path to input image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br></pre></td></tr></table></figure>

<h2 id="将图像转换为灰度"><a href="#将图像转换为灰度" class="headerlink" title="将图像转换为灰度"></a>将图像转换为灰度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load the input image (whose path was supplied via command line</span></span><br><span class="line"><span class="comment"># argument) and display the image to our screen</span></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert the image to grayscale</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">"Gray"</span>, gray)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191114124829347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘检测可用于查找图像中对象的边界，对于分割目的非常有效。<br>让我们执行边缘检测以查看该过程如何工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># applying edge detection we can find the outlines of objects in</span></span><br><span class="line"><span class="comment"># images</span></span><br><span class="line">edged = cv2.Canny(gray, 30, 150)</span><br><span class="line">cv2.imshow(<span class="string">"Edged"</span>, edged)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>使用流行的Canny算法（由John F. Canny在1986年开发），我们可以找到图像中的边缘。<br>我们为cv2.Canny提供的参数：<br>img  ： 灰色   图像。<br>minVal  ：最小阈值，在我们的示例中为 30  。<br>maxVal  ：最大阈值，  在我们的示例中为 150。<br>aperture_size  ：Sobel内核大小。默认情况下，此值为 3<br><img src="https://img-blog.csdnimg.cn/20191114125630765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图18：为了使用OpenCV进行边缘检测，我们使用了Canny算法。</p>
<h2 id="阈值"><a href="#阈值" class="headerlink" title="阈值"></a>阈值</h2><p>图像阈值化是图像处理管道的重要中间步骤。阈值处理可以帮助我们去除较亮或较暗的图像区域和轮廓。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># threshold the image by setting all pixel values less than 225</span></span><br><span class="line"><span class="comment"># to 255 (white; foreground) and all pixel values &gt;= 225 to 255</span></span><br><span class="line"><span class="comment"># (black; background), thereby segmenting the image</span></span><br><span class="line">thresh = cv2.threshold(gray, 225, 255, cv2.THRESH_BINARY_INV)[1]</span><br><span class="line">cv2.imshow(<span class="string">"Thresh"</span>, thresh)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p>将像素值大于225的灰度图像中的所有像素设置为0（黑色），这对应于图像的背景<br>将像素值为小于225灰度图像中的所有像素设置255（白色），该值对应于图像的前景（即，俄罗斯方块本身）<br><img src="https://img-blog.csdnimg.cn/20191114130050791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>图19：在找到轮廓之前，我们先对灰度图像进行阈值处理。我们执行了二进制反阈值，以使前景形状变为白色，而背景变为黑色。</p>
<h2 id="检测和绘制轮廓"><a href="#检测和绘制轮廓" class="headerlink" title="检测和绘制轮廓"></a>检测和绘制轮廓</h2><p><img src="https://img-blog.csdnimg.cn/20191114130230355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find contours (i.e., outlines) of the foreground objects in the</span></span><br><span class="line"><span class="comment"># thresholded image</span></span><br><span class="line">cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,</span><br><span class="line">	cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = imutils.grab_contours(cnts)</span><br><span class="line">output = image.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop over the contours</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cnts:</span><br><span class="line">	<span class="comment"># draw each contour on the output image with a 3px thick purple</span></span><br><span class="line">	<span class="comment"># outline, then display the output contours one at a time</span></span><br><span class="line">	cv2.drawContours(output, [c], -1, (240, 0, 159), 3)</span><br><span class="line">	cv2.imshow(<span class="string">"Contours"</span>, output)</span><br><span class="line">	cv2.waitKey(0)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># draw the total number of contours found in purple</span></span><br><span class="line">text = <span class="string">"I found &#123;&#125; objects!"</span>.format(len(cnts))</span><br><span class="line">cv2.putText(output, text, (10, 25),  cv2.FONT_HERSHEY_SIMPLEX, 0.7,</span><br><span class="line">	(240, 0, 159), 2)</span><br><span class="line">cv2.imshow(<span class="string">"Contours"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191114131811865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="侵蚀和膨胀"><a href="#侵蚀和膨胀" class="headerlink" title="侵蚀和膨胀"></a>侵蚀和膨胀</h2><p>侵蚀和膨胀通常用于减少二进制图像中的噪声（阈值的副作用）。<br>为了减少前景对象的大小，我们可以通过多次迭代来侵蚀掉像素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># we apply erosions to reduce the size of foreground objects</span></span><br><span class="line">mask = thresh.copy()</span><br><span class="line">mask = cv2.erode(mask, None, iterations=5)</span><br><span class="line">cv2.imshow(<span class="string">"Eroded"</span>, mask)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191114132637834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="遮挡和按位运算"><a href="#遮挡和按位运算" class="headerlink" title="遮挡和按位运算"></a>遮挡和按位运算</h2><p>遮罩允许我们“遮罩”我们不感兴趣的图像区域。我们称它们为“遮罩”是因为它们将  隐藏我们不关心的图像区域。<br><img src="https://img-blog.csdnimg.cn/20191114132821216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQyNjgzMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a typical operation we may want to apply is to take our mask and</span></span><br><span class="line"><span class="comment"># apply a bitwise AND to our input image, keeping only the masked</span></span><br><span class="line"><span class="comment"># regions</span></span><br><span class="line">mask = thresh.copy()</span><br><span class="line">output = cv2.bitwise_and(image, image, mask=mask)</span><br><span class="line">cv2.imshow(<span class="string">"Output"</span>, output)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/29/My-New-Post/" data-id="ckas22eyk00009guh3wauante" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/29/hello-world/" class="article-date">
  <time datetime="2020-05-29T09:45:12.762Z" itemprop="datePublished">2020-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/29/hello-world/" data-id="ckas0v6p70000gwuh1ez84tvn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/29/My-New-Post/">My New Post</a>
          </li>
        
          <li>
            <a href="/2020/05/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 chen peng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>